//! All blocks and block data
//!
//! @generated by `froglight-generator #dc73c64`

use std::{ops::Range, sync::Arc};

use bevy_app::App;
use bevy_ecs::{reflect::ReflectResource, system::Resource};
use bevy_log::{trace, warn};
use bevy_reflect::{Reflect, TypePath};
use derive_more::Deref;
use froglight_protocol::{
    traits::Version,
    versions::{v1_20_0::V1_20_0, v1_20_2::V1_20_2, v1_20_3::V1_20_3},
};
use parking_lot::RwLock;
use rangemap::RangeMap;

use super::BlockType;

#[doc(hidden)]
pub(super) fn build(app: &mut App) {
    BlockRegistry::<V1_20_0>::init(app);
    BlockRegistry::<V1_20_2>::init(app);
    BlockRegistry::<V1_20_3>::init(app);
}

/// A registry containing all of the blocks for a specific [`Version`]
#[derive(Debug, Default, Clone, Deref, Reflect, Resource)]
#[reflect(Resource)]
pub struct BlockRegistry<V: Version>(#[reflect(ignore)] Arc<RwLock<BlockRegistryInner<V>>>)
where
    BlockRegistryInner<V>: Default;

impl<V: Version + TypePath> BlockRegistry<V>
where
    BlockRegistryInner<V>: Default,
{
    /// A shortcut for registering for reflection
    #[cfg(not(feature = "inspector"))]
    fn init(app: &mut App) {
        app.register_type::<BlockRegistry<V>>()
            .register_type::<BlockRegistryInner<V>>()
            .init_resource::<BlockRegistry<V>>();
    }

    /// A shortcut for registering for reflection
    #[cfg(feature = "inspector")]
    fn init(app: &mut App) {
        app.register_type::<BlockRegistryInner<V>>().register_type::<BlockRegistry<V>>();

        // Add a custom reflect implementation for `BlockRegistry<V>`
        {
            let registry = app.world.resource::<bevy_ecs::prelude::AppTypeRegistry>();
            let mut registry = registry.write();

            let arc_manager = registry.get_mut(std::any::TypeId::of::<BlockRegistry<V>>()).unwrap();
            arc_manager.insert(BlockRegistry::<V>::egui_impl());
        }

        app.init_resource::<BlockRegistry<V>>();
    }
}

/// A registry containing all of the blocks for a specific [`Version`]
#[derive(Debug, Reflect)]
pub struct BlockRegistryInner<V: Version> {
    /// The blocks in the registry
    ///
    /// This is a vector of all the blocks in the registry.
    #[reflect(ignore)]
    pub blocks: Vec<Box<dyn BlockType<V>>>,

    /// The block states in the registry
    ///
    /// This is a map of block state ids to block ids.
    ///
    /// ---
    ///
    /// # Usage
    ///
    /// For example, if the server sends a block state id of `2`, the client
    /// will look up that state id in this map to find the block id.
    ///
    /// The client then uses the resulting index to look up the block
    /// in the `blocks` vector.
    #[reflect(ignore)]
    pub block_states: RangeMap<usize, usize>,

    #[reflect(ignore)]
    pub(crate) _version: std::marker::PhantomData<V>,
}

impl<V: Version> BlockRegistryInner<V> {
    /// Gets the block id for the given state id
    pub fn get_blockid(&self, state_id: usize) -> Option<usize> {
        self.block_states.get(&state_id).copied()
    }

    /// Gets the block with the given block id
    ///
    /// Not to be confused with [`get_block_from_state`]
    pub fn get_block(&self, block_id: usize) -> Option<&dyn BlockType<V>> {
        self.blocks.get(block_id).map(AsRef::as_ref)
    }

    /// Gets the block with the given state id
    pub fn get_block_from_state(&self, state_id: usize) -> Option<&dyn BlockType<V>> {
        if let Some(block_id) = self.block_states.get(&state_id) {
            trace!("Got Block from State ID: {state_id} -> {block_id}");
            if let Some(block) = self.blocks.get(*block_id) {
                trace!("Got Block from Block ID: {block_id} -> {}", block.resource_key());
                Some(block.as_ref())
            } else {
                warn!("Attempted to get Block from unregistered Block ID: {block_id}");
                None
            }
        } else {
            warn!("Attempted to get Block from unregistered State ID: {state_id}");
            None
        }
    }

    /// Registers a block with the block registry
    ///
    /// This will add the block to the registry and update the block states map.
    ///
    /// # Note
    ///
    /// Do not register the same block twice!
    ///
    /// ---
    ///
    /// This should be done for every block and is order dependent.
    pub fn register_block(&mut self, block: impl BlockType<V>) -> &mut Self {
        let block_id = self.blocks.len();
        let state_count = block.states();

        // Add the block to the registry
        self.blocks.push(Box::new(block));

        // Insert the range of states into the block states map
        if let Some((last_range, _)) = self.block_states.last_range_value() {
            // Insert the range starting at the end of the last index
            self.block_states.insert(
                Range { start: last_range.end, end: last_range.end + state_count },
                block_id,
            );
        } else {
            // Insert the range starting at 0
            self.block_states.insert(Range { start: 0, end: state_count }, block_id);
        }

        self
    }
}
