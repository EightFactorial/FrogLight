use std::{io::Write, path::PathBuf};

use convert_case::{Case, Casing};
use git2::Repository;
use json::JsonValue;
use log::error;
use mc_rs_ext::{extract::datasets::Datasets, types::Version};
use proc_macro2::Span;
use syn::{
    punctuated::Punctuated, Attribute, Fields, Generics, Ident, Item, ItemEnum, MacroDelimiter,
    Meta, MetaList, Path, PathArguments, PathSegment, Variant, Visibility,
};

use crate::generate::{Generator, Generators};

/// Generates the blocks module.
#[derive(Debug, Default, Clone, Copy, PartialEq, Eq, Hash)]
pub struct BlockAttributes;

impl Generator for BlockAttributes {
    fn deps(&self) -> &'static [Datasets] {
        &[Datasets::BlockStates(
            mc_rs_ext::extract::datasets::block::BlockStates,
        )]
    }

    fn parse(&self, _version: &Version, data: &JsonValue, repo: &Repository) {
        let mut path: PathBuf = repo.path().parent().unwrap().into();
        path.push("crates/mc-rs");

        // Check if the mc-rs crate exists
        if !path.exists() {
            error!("mc-rs crate not found at {}", path.display());
            error!("Is this the right git repository?");
            return;
        }

        Self::create_enums(path.clone(), data);
    }
}

impl BlockAttributes {
    /// Creates the attribute enums.
    fn create_enums(mut path: PathBuf, data: &JsonValue) {
        // Get the attribut enums module
        path.push("src/systems/blocks/attributes/enums.rs");
        if !path.exists() {
            error!("`attributes.rs` not found at {}", path.display());
            return;
        }

        let Some(mut code) = Generators::get_code(&path) else {
            error!("Failed to read `attributes.rs`");
            return;
        };

        // Remove all of the old attribute enums and create new ones
        code.items.retain(|item| !matches!(item, Item::Enum(_)));

        // Create new attribute enums
        data["blocks"]["states"]["states"]
            .entries()
            .for_each(|(name, value)| {
                let kind = value["type"].as_str().unwrap();
                if !matches!(kind, "enum") {
                    return;
                }

                let name = attribute_name(name);
                let name_ident = Ident::new(&name, Span::call_site());

                // Create the enum
                code.items.push(create_enum(name_ident, value));
            });

        // Also create the `DirectionAttribute` enum
        code.items.push(create_enum(
            Ident::new(&attribute_name("Direction"), Span::call_site()),
            &json::object! {
                "values": {
                    "down": {},
                    "up": {},
                    "north": {},
                    "south": {},
                    "west": {},
                    "east": {},
                }
            },
        ));

        // Write the new code to the file
        let mut output = Vec::new();
        writeln!(output, "// This file is automatically generated!").unwrap();
        writeln!(output, "// Do not manually edit it!").unwrap();
        writeln!(output).unwrap();

        output.extend(prettyplease::unparse(&code).as_bytes());

        if let Err(e) = std::fs::write(&path, output) {
            error!("Failed to write `attributes.rs`, {}", e);
        }
    }
}

/// Creates the name for the attribute type.
fn attribute_name(name: &str) -> String { format!("{}Attribute", name.to_case(Case::Pascal)) }

/// Creates an attribute enum with the given identity and data.
fn create_enum(ident: Ident, enum_data: &JsonValue) -> Item {
    let mut variants = Punctuated::new();

    enum_data["values"].entries().for_each(|(name, _)| {
        let name = name.to_case(Case::Pascal);
        let name_ident = Ident::new(&name, Span::call_site());

        variants.push(Variant {
            attrs: Vec::new(),
            ident: name_ident,
            fields: Fields::Unit,
            discriminant: None,
        });
    });

    ItemEnum {
        attrs: vec![Attribute {
            pound_token: syn::token::Pound::default(),
            style: syn::AttrStyle::Outer,
            bracket_token: syn::token::Bracket::default(),
            meta: Meta::List(MetaList {
                path: Path {
                    leading_colon: None,
                    segments: {
                        let mut segments = Punctuated::new();
                        segments.push(PathSegment {
                            ident: Ident::new("derive", Span::call_site()),
                            arguments: PathArguments::None,
                        });
                        segments
                    },
                },
                delimiter: MacroDelimiter::Paren(syn::token::Paren::default()),
                tokens: quote::quote! { Debug, Clone, Copy, PartialEq, Eq, Hash },
            }),
        }],
        vis: Visibility::Public(syn::token::Pub::default()),
        enum_token: syn::token::Enum::default(),
        ident,
        generics: Generics {
            lt_token: None,
            params: Punctuated::new(),
            gt_token: None,
            where_clause: None,
        },
        brace_token: syn::token::Brace::default(),
        variants,
    }
    .into()
}
