use std::{
    fs::File,
    io::{Read, Write},
    path::PathBuf,
};

use convert_case::{Case, Casing};
use git2::Repository;
use json::JsonValue;
use log::error;
use mc_rs_ext::{extract::datasets::Datasets, types::Version};
use proc_macro2::Span;
use syn::{
    punctuated::Punctuated, AngleBracketedGenericArguments, Attribute, Field, FieldMutability,
    Fields, FieldsNamed, GenericArgument, Generics, Ident, Item, ItemEnum, MacroDelimiter, Meta,
    MetaList, Path, PathArguments, PathSegment, Type, TypePath, Variant, Visibility,
};

use crate::generate::Generator;

/// Generates the blocks module.
#[derive(Debug, Default, Clone, Copy, PartialEq, Eq, Hash)]
pub struct BlockAttributes;

impl Generator for BlockAttributes {
    fn deps(&self) -> &'static [Datasets] {
        &[Datasets::BlockStates(
            mc_rs_ext::extract::datasets::block::BlockStates,
        )]
    }

    fn parse(&self, _version: &Version, data: &JsonValue, repo: &Repository) {
        let mut path: PathBuf = repo.path().parent().unwrap().into();
        path.push("crates/mc-rs");

        // Check if the mc-rs crate exists
        if !path.exists() {
            error!("mc-rs crate not found at {}", path.display());
            error!("Is this the right git repository?");
            return;
        }

        // Get the block attributes module
        path.push("src/systems/blocks/attributes/mod.rs");
        if !path.exists() {
            error!("`attributes.rs` not found at {}", path.display());
            return;
        }

        // Read the file
        let mut content = String::new();
        {
            let mut file = match File::open(&path) {
                Ok(file) => file,
                Err(e) => {
                    error!("Failed to open `attributes/mod.rs`, {}", e);
                    return;
                }
            };

            if let Err(e) = file.read_to_string(&mut content) {
                error!("Failed to read `attributes/mod.rs`, {}", e);
                return;
            }
        }

        // Parse the code
        let mut code = match syn::parse_file(&content) {
            Ok(file) => file,
            Err(err) => {
                error!("Failed to parse `attributes/mod.rs`, {}", err);
                return;
            }
        };

        // Find the `BlockAttributes` struct
        let Some(Item::Struct(block_attributes)) = code.items.iter_mut().find(|item| {
            if let syn::Item::Struct(item) = item {
                item.ident == "BlockAttributes"
            } else {
                false
            }
        }) else {
            error!("Failed to find `BlockAttributes` struct");
            return;
        };

        // Generate new `BlockAttributes` fields
        block_attributes.fields = Self::blockattributes_fields(data);

        // Remove all of the old attribute enums and create new ones
        code.items.retain(|item| !matches!(item, Item::Enum(_)));
        Self::attribute_enums(&mut code, data);

        // Write the new code to the file
        let mut output = Vec::new();
        writeln!(output, "// This file is automatically generated!").unwrap();
        writeln!(output, "// Run mc-rs-gen to regenerate it!").unwrap();
        writeln!(output).unwrap();

        output.extend(prettyplease::unparse(&code).as_bytes());

        if let Err(e) = std::fs::write(&path, output) {
            error!("Failed to write `attributes.rs`, {}", e);
        }
    }
}

impl BlockAttributes {
    /// Generates the fields for the `BlockAttributes` struct.
    fn blockattributes_fields(data: &JsonValue) -> Fields {
        let mut named = Punctuated::new();

        let states = &data["blocks"]["states"]["states"];
        states.entries().for_each(|(name, value)| {
            let name = name.to_case(Case::Snake);
            let name_ident = Ident::new(&name, Span::call_site());

            let kind = match value["type"].as_str().unwrap() {
                "boolean" => "bool".to_string(),
                "integer" => "i32".to_string(),
                "direction" => Self::attribute_name("Direction"),
                "enum" => Self::attribute_name(&name),
                _ => unreachable!("Unknown kind"),
            };
            let kind_ident = Ident::new(&kind, Span::call_site());

            // Create an optional field with the name and type
            named.push(Self::create_optional_field(name_ident, kind_ident));
        });

        FieldsNamed {
            brace_token: Default::default(),
            named,
        }
        .into()
    }

    /// Creates the name for the attribute type.
    fn attribute_name(name: &str) -> String { format!("{}Attribute", name.to_case(Case::Pascal)) }

    /// Creates the attribute enums.
    fn attribute_enums(code: &mut syn::File, data: &JsonValue) {
        let states = &data["blocks"]["states"]["states"];
        states.entries().for_each(|(name, value)| {
            let kind = value["type"].as_str().unwrap();
            if !matches!(kind, "enum") {
                return;
            }

            let name = Self::attribute_name(name);
            let name_ident = Ident::new(&name, Span::call_site());

            // Create the enum
            code.items.push(Self::create_enum(name_ident, value));
        });

        // Also create the `DirectionAttribute` enum
        code.items.push(Self::create_enum(
            Ident::new(&Self::attribute_name("Direction"), Span::call_site()),
            &json::object! {
                "values": {
                    "down": {},
                    "up": {},
                    "north": {},
                    "south": {},
                    "west": {},
                    "east": {},
                }
            },
        ));
    }

    /// Creates an attribute enum with the given name and data.
    fn create_enum(ident: Ident, enum_data: &JsonValue) -> Item {
        let mut variants = Punctuated::new();

        enum_data["values"].entries().for_each(|(name, _)| {
            let name = name.to_case(Case::Pascal);
            let name_ident = Ident::new(&name, Span::call_site());

            variants.push(Variant {
                attrs: Vec::new(),
                ident: name_ident,
                fields: Fields::Unit,
                discriminant: None,
            });
        });

        ItemEnum {
            attrs: vec![Attribute {
                pound_token: syn::token::Pound::default(),
                style: syn::AttrStyle::Outer,
                bracket_token: syn::token::Bracket::default(),
                meta: Meta::List(MetaList {
                    path: Path {
                        leading_colon: None,
                        segments: {
                            let mut segments = Punctuated::new();
                            segments.push(PathSegment {
                                ident: Ident::new("derive", Span::call_site()),
                                arguments: PathArguments::None,
                            });
                            segments
                        },
                    },
                    delimiter: MacroDelimiter::Paren(syn::token::Paren::default()),
                    tokens: quote::quote! { Debug, Clone, Copy, PartialEq, Eq, Hash },
                }),
            }],
            vis: Visibility::Public(syn::token::Pub::default()),
            enum_token: syn::token::Enum::default(),
            ident,
            generics: Generics {
                lt_token: None,
                params: Punctuated::new(),
                gt_token: None,
                where_clause: None,
            },
            brace_token: syn::token::Brace::default(),
            variants,
        }
        .into()
    }

    /// Creates an optional field with the given name and type.
    fn create_optional_field(ident: Ident, ty: Ident) -> Field {
        Field {
            attrs: Vec::new(),
            vis: Visibility::Public(syn::token::Pub::default()),
            mutability: FieldMutability::None,
            colon_token: Some(syn::token::Colon::default()),
            ident: Some(ident),
            ty: Type::Path(TypePath {
                qself: None,
                path: Path {
                    leading_colon: None,
                    segments: {
                        let mut segments = Punctuated::new();

                        segments.push(PathSegment {
                            ident: Ident::new("Option", Span::call_site()),
                            arguments: PathArguments::AngleBracketed(
                                AngleBracketedGenericArguments {
                                    colon2_token: None,
                                    lt_token: syn::token::Lt::default(),
                                    gt_token: syn::token::Gt::default(),
                                    args: {
                                        let mut args = Punctuated::new();

                                        args.push(GenericArgument::Type(Type::Path(TypePath {
                                            qself: None,
                                            path: Path {
                                                leading_colon: None,
                                                segments: {
                                                    let mut segments = Punctuated::new();
                                                    segments.push(PathSegment {
                                                        ident: ty,
                                                        arguments: PathArguments::None,
                                                    });
                                                    segments
                                                },
                                            },
                                        })));

                                        args
                                    },
                                },
                            ),
                        });

                        segments
                    },
                },
            }),
        }
    }
}
