use std::{io::Write, path::PathBuf};

use convert_case::{Case, Casing};
use git2::Repository;
use json::JsonValue;
use log::{error, warn};
use mc_rs_ext::{
    extract::datasets::{self, block::Block, Datasets},
    types::Version,
};
use proc_macro2::{Span, TokenStream};
use syn::{
    punctuated::Punctuated, Ident, Item, Macro, MacroDelimiter, Path, PathArguments, PathSegment,
    Stmt, StmtMacro,
};

use crate::generate::{Generator, Generators};

#[derive(Debug, Default, Clone, Copy, PartialEq, Eq, Hash)]
pub struct Blocks;

impl Generator for Blocks {
    fn deps(&self) -> &'static [Datasets] {
        &[datasets::Datasets::BlockStates(
            datasets::block::BlockStates,
        )]
    }

    fn parse(&self, _version: &Version, data: &JsonValue, repo: &Repository) {
        let mut path: PathBuf = repo.path().parent().unwrap().into();
        path.push("crates/mc-rs/src/systems/blocks/block/list.rs");

        if !path.exists() {
            error!("`block/list.rs` not found at {}", path.display());
            return;
        }

        let Some(mut code) = Generators::get_code(&path) else {
            error!("Failed to read `block/list.rs`");
            return;
        };

        let Some(Item::Fn(ref mut create_fn)) = code.items.iter_mut().find(|item| {
            if let Item::Fn(func) = item {
                func.sig.ident == "create_blocks"
            } else {
                false
            }
        }) else {
            error!("Failed to find `create` function in `block/list.rs`");
            return;
        };

        let macro_calls = &mut create_fn.block.stmts;
        macro_calls.clear();

        let block_list = &data["blocks"]["blocks"]["blocks"];
        let default_block = Block::default();

        // Loop through all blocks in order
        let mut state_id = 0;
        for block_id in 0..block_list.len() as u32 {
            let Some(index) = block_list
                .entries()
                .position(|(_, b)| b["id"].as_u32().unwrap() == block_id)
            else {
                warn!("Missing block with id {block_id}");
                continue;
            };

            let (name, block_data) = block_list.entries().nth(index).unwrap();
            let name = name.to_case(Case::Title);

            // Get block properties that are not the default value
            let mut properties = TokenStream::new();
            get_properties(&mut properties, &default_block, block_data);

            let max_id = state_id + get_state_count(block_data, data) - 1;

            let add_block = call_add_block(quote::quote! {
                blocks,
                #block_id,
                #state_id..=#max_id,
                #name,
                BlockProperties {
                    #properties
                    ..Default::default()
                }
            });

            state_id = max_id + 1;
            macro_calls.push(add_block);
        }

        // Write the new code to the file
        let mut output = Vec::new();
        writeln!(output, "// This file is automatically generated!").unwrap();
        writeln!(output, "// Do not manually edit it!").unwrap();
        writeln!(output).unwrap();

        output.extend(prettyplease::unparse(&code).as_bytes());

        if let Err(err) = std::fs::write(&path, output) {
            error!("Failed to write `attributes.rs`, {err}");
        }
    }
}

fn get_properties(properties: &mut TokenStream, default_block: &Block, block_data: &JsonValue) {
    if default_block.hardness != block_data["hardness"].as_f32().unwrap() {
        let val = block_data["hardness"].as_f32().unwrap();
        properties.extend(quote::quote! {
            hardness: #val,
        });
    }

    if default_block.resistance != block_data["resistance"].as_f32().unwrap() {
        let val = block_data["resistance"].as_f32().unwrap();
        properties.extend(quote::quote! {
            resistance: #val,
        });
    }

    if default_block.friction != block_data["friction"].as_f32().unwrap() {
        let val = block_data["friction"].as_f32().unwrap();
        properties.extend(quote::quote! {
            friction: #val,
        });
    }

    if default_block.velocity_multiplier != block_data["velocity_multiplier"].as_f32().unwrap() {
        let val = block_data["velocity_multiplier"].as_f32().unwrap();
        properties.extend(quote::quote! {
            velocity_multiplier: #val,
        });
    }

    if default_block.jump_velocity_multiplier
        != block_data["jump_velocity_multiplier"].as_f32().unwrap()
    {
        let val = block_data["jump_velocity_multiplier"].as_f32().unwrap();
        properties.extend(quote::quote! {
            jump_velocity_multiplier: #val,
        });
    }

    if default_block.random_ticks != block_data["random_ticks"].as_bool().unwrap() {
        let val = block_data["random_ticks"].as_bool().unwrap();
        properties.extend(quote::quote! {
            random_ticks: #val,
        });
    }

    if default_block.burnable != block_data["burnable"].as_bool().unwrap() {
        let val = block_data["burnable"].as_bool().unwrap();
        properties.extend(quote::quote! {
            burnable: #val,
        });
    }

    if default_block.collidable != block_data["collidable"].as_bool().unwrap() {
        let val = block_data["collidable"].as_bool().unwrap();
        properties.extend(quote::quote! {
            collidable: #val,
        });
    }

    if default_block.opaque != block_data["opaque"].as_bool().unwrap() {
        let val = block_data["opaque"].as_bool().unwrap();
        properties.extend(quote::quote! {
            opaque: #val,
        });
    }

    if default_block.is_air != block_data["is_air"].as_bool().unwrap() {
        let val = block_data["is_air"].as_bool().unwrap();
        properties.extend(quote::quote! {
            is_air: #val,
        });
    }

    if default_block.is_fluid != block_data["is_fluid"].as_bool().unwrap() {
        let val = block_data["is_fluid"].as_bool().unwrap();
        properties.extend(quote::quote! {
            is_fluid: #val,
        });
    }
}

/// Get the number of states for a block
fn get_state_count(block_data: &JsonValue, data: &JsonValue) -> u32 {
    let states = &data["blocks"]["states"]["states"];

    let mut state_count = 1u32;

    for state in block_data["states"].members() {
        let state = state.as_str().unwrap();

        let state_data = &states[state];
        state_count *= match state_data["type"].as_str().unwrap() {
            "boolean" => 2,
            "direction" | "enum" => states[state]["values"].entries().count() as u32,
            "integer" => match state {
                "AGE_1" => 2,
                "AGE_2" => 3,
                "AGE_3" => 4,
                "AGE_4" => 5,
                "AGE_5" => 6,
                "AGE_7" => 8,
                "AGE_15" => 16,
                "AGE_25" => 26,
                "BITES" => 6,
                "CANDLES" => 4,
                "CHARGES" => 5,
                "DELAY" => 4,
                "DISTANCE_0_7" => 8,
                "DISTANCE_1_7" => 7,
                "DUSTED" => 4,
                "EGGS" => 3,
                "FLOWER_AMOUNT" => 4,
                "HATCH" => 3,
                "HONEY_LEVEL" => 6,
                "LAYERS" => 8,
                "LEVEL_1_8" => 8,
                "LEVEL_3" => 3,
                "LEVEL_8" => 9,
                "LEVEL_15" => 16,
                "MOISTURE" => 8,
                "NOTE" => 25,
                "PICKLES" => 4,
                "POWER" => 16,
                "ROTATION" => 16,
                "STAGE" => 2,
                _ => {
                    error!("Unknown integer state {state}");
                    1
                }
            },
            state => {
                error!("Unknown state type {state}");
                continue;
            }
        }
    }

    state_count
}

fn call_add_block(tokens: TokenStream) -> Stmt {
    Stmt::Macro(StmtMacro {
        attrs: vec![],
        mac: Macro {
            path: Path {
                leading_colon: None,
                segments: {
                    let mut segments = Punctuated::new();
                    segments.push(PathSegment {
                        ident: Ident::new("add_block", Span::call_site()),
                        arguments: PathArguments::None,
                    });
                    segments
                },
            },
            bang_token: syn::token::Not::default(),
            delimiter: MacroDelimiter::Paren(syn::token::Paren::default()),
            tokens,
        },
        semi_token: Some(syn::token::Semi::default()),
    })
}
