use std::{io::Write, path::PathBuf};

use convert_case::{Case, Casing};
use git2::Repository;
use json::JsonValue;
use mc_rs_extract::{extract::datasets::Datasets, types::Version};
use proc_macro2::Span;
use syn::{punctuated::Punctuated, *};
use tracing::error;

use crate::generate::{Generator, Generators};

/// Generates the blocks module.
#[derive(Debug, Default, Clone, Copy, PartialEq, Eq, Hash)]
pub struct BlockAttributes;

impl Generator for BlockAttributes {
    fn deps(&self) -> &'static [Datasets] {
        &[Datasets::BlockStates(
            mc_rs_extract::extract::datasets::block::BlockStates,
        )]
    }

    fn parse(&self, _version: &Version, data: &JsonValue, repo: &Repository) {
        let path: PathBuf = repo.path().parent().unwrap().into();

        // Check if the mc-rs crate exists
        if !path.exists() {
            error!("mc-rs crate not found at {}", path.display());
            error!("Is this the right git repository?");
            return;
        }

        Self::create_enums(path.clone(), data);
        Self::create_trait_fns(path.clone(), data);
        Self::impl_trait(path, data);
    }
}

impl BlockAttributes {
    /// Create the attribute enums.
    fn create_enums(mut path: PathBuf, data: &JsonValue) {
        // Get the attribute enums module
        path.push("src/systems/blocks/attributes/enums.rs");
        if !path.exists() {
            error!("`attributes.rs` not found at {}", path.display());
            return;
        }

        let Some(mut code) = Generators::get_code(&path) else {
            error!("Failed to read `attributes.rs`");
            return;
        };

        // Remove all of the old attribute enums and create new ones
        code.items.retain(|item| !matches!(item, Item::Enum(_)));

        // Create new attribute enums
        data["blocks"]["states"]["states"]
            .entries()
            .for_each(|(name, value)| {
                let kind = value["type"].as_str().unwrap();
                if !matches!(kind, "enum") {
                    return;
                }

                let name = attribute_name(name);
                let name_ident = Ident::new(&name, Span::call_site());

                // Create the enum
                code.items.push(create_enum(name_ident, value));
            });

        // Also create the `DirectionAttribute` enum
        code.items.push(create_enum(
            Ident::new(&attribute_name("Direction"), Span::call_site()),
            &json::object! {
                "values": {
                    "down": {},
                    "up": {},
                    "north": {},
                    "south": {},
                    "west": {},
                    "east": {},
                }
            },
        ));

        // Write the new code to the file
        let mut output = Vec::new();
        writeln!(output, "// This file is automatically generated!").unwrap();
        writeln!(output, "// Do not manually edit it!").unwrap();
        writeln!(output).unwrap();

        output.extend(prettyplease::unparse(&code).as_bytes());

        if let Err(err) = std::fs::write(&path, output) {
            error!("Failed to write `attributes.rs`, {err}");
        }
    }

    /// Create the attribute trait.
    fn create_trait_fns(mut path: PathBuf, data: &JsonValue) {
        // Get the attribute trait module
        path.push("src/systems/blocks/attributes/attr_trait.rs");
        if !path.exists() {
            error!("`attr_trait.rs` not found at {}", path.display());
            return;
        }

        let Some(mut code) = Generators::get_code(&path) else {
            error!("Failed to read `attr_trait.rs`");
            return;
        };

        // Remove all of the old super imports
        code.items.retain(|item| {
            if let Item::Use(ItemUse {
                tree: UseTree::Path(path),
                ..
            }) = item
            {
                path.ident != "super"
            } else {
                true
            }
        });

        // Get the trait
        let Some(Item::Trait(ref mut attr_trait)) = code.items.iter_mut().find(|item| {
            if let Item::Trait(item) = item {
                item.ident == "BlockAttributeTrait"
            } else {
                false
            }
        }) else {
            error!("Failed to find `BlockAttributeTrait` trait");
            return;
        };

        // Remove all of the old functions and create new ones
        attr_trait
            .items
            .retain(|item| !matches!(item, TraitItem::Fn(_)));

        let mut imports = Vec::new();
        data["blocks"]["states"]["states"]
            .entries()
            .for_each(|(name, value)| {
                let output = match value["type"].as_str().unwrap() {
                    "integer" => "i32".to_string(),
                    "boolean" => "bool".to_string(),
                    "direction" => {
                        let out = attribute_name("direction");
                        imports.push(out.clone());
                        out
                    }
                    "enum" => {
                        let out = attribute_name(name);
                        imports.push(out.clone());
                        out
                    }
                    _ => unreachable!("Unknown attribute type"),
                };
                let output_ident = Ident::new(&output, Span::call_site());

                let name_ident = Ident::new(&name.to_ascii_lowercase(), Span::call_site());
                attr_trait
                    .items
                    .push(create_trait_fn(name_ident, output_ident));
            });

        // Write the new code to the file
        let mut output = Vec::new();
        writeln!(output, "// This file is automatically generated!").unwrap();
        writeln!(output, "// Do not manually edit it!").unwrap();
        writeln!(output).unwrap();

        writeln!(output, "use super::{{{}}};", imports.join(", ")).unwrap();
        writeln!(output).unwrap();

        output.extend(prettyplease::unparse(&code).as_bytes());

        if let Err(err) = std::fs::write(&path, output) {
            error!("Failed to write `attr_trait.rs`, {err}");
        }
    }

    /// Implement the trait.
    fn impl_trait(mut path: PathBuf, _data: &JsonValue) {
        // Get the trait impl module
        path.push("src/systems/blocks/attributes/attr_impl.rs");
        if !path.exists() {
            error!("`attr_impl.rs` not found at {}", path.display());
            return;
        }

        let Some(mut _code) = Generators::get_code(&path) else {
            error!("Failed to read `attr_impl.rs`");
            return;
        };
    }
}

/// Creates the name for the attribute type.
fn attribute_name(name: &str) -> String { format!("{}Attribute", name.to_case(Case::Pascal)) }

/// Creates an attribute enum with the given identity and data.
fn create_enum(ident: Ident, enum_data: &JsonValue) -> Item {
    let mut variants = Punctuated::new();

    enum_data["values"].entries().for_each(|(name, _)| {
        let name = name.to_case(Case::Pascal);
        let name_ident = Ident::new(&name, Span::call_site());

        variants.push(Variant {
            attrs: Vec::new(),
            ident: name_ident,
            fields: Fields::Unit,
            discriminant: None,
        });
    });

    ItemEnum {
        attrs: vec![Attribute {
            pound_token: syn::token::Pound::default(),
            style: syn::AttrStyle::Outer,
            bracket_token: syn::token::Bracket::default(),
            meta: Meta::List(MetaList {
                path: Path {
                    leading_colon: None,
                    segments: {
                        let mut segments = Punctuated::new();
                        segments.push(PathSegment {
                            ident: Ident::new("derive", Span::call_site()),
                            arguments: PathArguments::None,
                        });
                        segments
                    },
                },
                delimiter: MacroDelimiter::Paren(syn::token::Paren::default()),
                tokens: quote::quote! { Debug, Clone, Copy, PartialEq, Eq, Hash },
            }),
        }],
        vis: Visibility::Public(syn::token::Pub::default()),
        enum_token: syn::token::Enum::default(),
        ident,
        generics: Generics {
            lt_token: None,
            params: Punctuated::new(),
            gt_token: None,
            where_clause: None,
        },
        brace_token: syn::token::Brace::default(),
        variants,
    }
    .into()
}

fn create_trait_fn(ident: Ident, output: Ident) -> TraitItem {
    TraitItemFn {
        attrs: Vec::new(),
        sig: Signature {
            constness: None,
            asyncness: None,
            unsafety: None,
            abi: None,
            fn_token: syn::token::Fn::default(),
            ident,
            generics: Generics {
                lt_token: None,
                params: Punctuated::new(),
                gt_token: None,
                where_clause: None,
            },
            paren_token: syn::token::Paren::default(),
            inputs: {
                let mut inputs = Punctuated::new();
                inputs.push(FnArg::Receiver(Receiver {
                    attrs: Vec::new(),
                    reference: Some((syn::token::And::default(), None)),
                    mutability: None,
                    self_token: syn::token::SelfValue::default(),
                    colon_token: None,
                    ty: Box::new(Type::Reference(TypeReference {
                        and_token: syn::token::And::default(),
                        lifetime: None,
                        mutability: None,
                        elem: Box::new(Type::Path(TypePath {
                            qself: None,
                            path: Path {
                                leading_colon: None,
                                segments: {
                                    let mut segments = Punctuated::new();
                                    segments.push(PathSegment {
                                        ident: Ident::new("Self", Span::call_site()),
                                        arguments: PathArguments::None,
                                    });
                                    segments
                                },
                            },
                        })),
                    })),
                }));
                inputs
            },
            variadic: None,
            output: ReturnType::Type(
                syn::token::RArrow::default(),
                Box::new(Type::Path(TypePath {
                    qself: None,
                    path: Path {
                        leading_colon: None,
                        segments: {
                            let mut segments = Punctuated::new();
                            segments.push(PathSegment {
                                ident: Ident::new("Option", Span::call_site()),
                                arguments: PathArguments::AngleBracketed(
                                    AngleBracketedGenericArguments {
                                        colon2_token: None,
                                        lt_token: syn::token::Lt::default(),
                                        args: {
                                            let mut args = Punctuated::new();
                                            args.push(GenericArgument::Type(Type::Path(
                                                TypePath {
                                                    qself: None,
                                                    path: Path {
                                                        leading_colon: None,
                                                        segments: {
                                                            let mut segments = Punctuated::new();
                                                            segments.push(PathSegment {
                                                                ident: output,
                                                                arguments: PathArguments::None,
                                                            });
                                                            segments
                                                        },
                                                    },
                                                },
                                            )));
                                            args
                                        },
                                        gt_token: syn::token::Gt::default(),
                                    },
                                ),
                            });
                            segments
                        },
                    },
                })),
            ),
        },
        default: Some(Block {
            brace_token: syn::token::Brace::default(),
            stmts: vec![
                (Stmt::Expr(
                    Expr::Path(ExprPath {
                        attrs: Vec::new(),
                        qself: None,
                        path: Path {
                            leading_colon: None,
                            segments: {
                                let mut segments = Punctuated::new();
                                segments.push(PathSegment {
                                    ident: Ident::new("None", Span::call_site()),
                                    arguments: PathArguments::None,
                                });
                                segments
                            },
                        },
                    }),
                    None,
                )),
            ],
        }),
        semi_token: Some(syn::token::Semi::default()),
    }
    .into()
}
